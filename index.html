<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>webCompounder</title>
    <link rel="icon" href="./favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" href="./simple.css" />
  </head>
  <body>
    <header>
      <br />
      <br />
      <h1>webCompounder</h1>
      <p>
        A tool to compound/combine/concatenate files;<br />made to simplify web
        development.
      </p>
      <nav>
        <a href="https://github.com/EhanAhamed/webCompounder"
          >Source Code (GitHub)</a
        ><a href="https://www.npmjs.com/package/webcompounder"
          >Node Module (npm)</a
        ><a href="https://github.com/EhanAhamed/webcompounder.ehan.dev/"
          >Website Source Code (GitHub)</a
        >
      </nav>
    </header>

    <main>
      <h2>üì¶ Installation</h2>
      <p>You can install webCompounder from npm, like any other npm package.</p>
      <pre><code>> npm install webcompounder --save-dev</code></pre>
      <p>
        You should <i>probably</i> install it as a developer dependency, using
        the <code>--save-dev</code> flag. (Unless you have a reason not to, of
        course.)
      </p>
      <p>
        Unlike some npm packages, webCompounder does <b>not</b> need to be
        installed globally to work. (It will only work within the folder it's
        installed into, though. But in most cases thats all you need.)
      </p>
      <br />
      <h2>üîß Command-Line Usage</h2>
      <p>
        webCompounder doesn't use a lot of flags or command line arguements,
        instead you set the options in a configuration file.
      </p>
      <p>
        If you have different workflows with different options, you can have
        multiple configuration files, and can run configuration file one at a
        time.
      </p>
      <p>
        Then you put the path to the configuration file as an arguement in the
        command.
      </p>
      <pre><code>> webCompounder ./pathTo/configFile.json</code></pre>
      <br />
      <h2>üìã Configuration Files</h2>
      <p>
        Configuration files are JSON files with an input value, an output value,
        and an optional callback value.
      </p>
      <p>
        The configuration file can have any filename and can be in any folder,
        but must be a json file and can <b>not</b> be outside of the root
        folder.
      </p>
      <p>Here's an example:</p>
      <pre><code>{
  "input": [
    "./pathTo/file.extension",
    "./pathTo/anotherFile.extension",
    "./yetAnother.extension"
  ],
  "output": "./pathToOutputFile/outputFile.extension",
  "callback": {
    "functionParameter": "variablePassedOnError",
    "functionBody": "if (variablePassedOnError) { /* do something on error*/ } else { /* do something when complete & no error */}"
  }
}</code></pre>
      <p>Here's another, more <i>real-world</i> example:</p>
      <pre><code>{
  "input": ["./src/utils/colors.js", "./src/utils/utils.js", "./src/main.js"],
  "output": "./build/main.build.js",
  "callback": {
    "functionParameter": "error",
    "functionBody": "if (error) { console.error('\n' + error + '\n') } else { console.log('\n' + 'Build Completed' + '\n') }"
  }
}</code></pre>
      <p>
        The input value is an array, and each string in the array is a file path
        to the files you want to merge together.
      </p>
      <p>
        The output value is a single string, and is a file path pointing to the
        file that all the other files will combine into.
      </p>
      <p>
        _All_ the file paths are relative to the **root** folder, where
        `package.json` is and where your terminal/shell session is, _even_ if
        the configuration file is **not** in the root folder, paths are
        **still** relative to the root folder!
      </p>
      <p>
        The callback value is an object. Inside of the callback value is a
        functionParameter value and a functionBody value. The functionParameter
        is the variable that gets passed on error. The functionBody is the body
        of your callback function.
      </p>
      <p>
        The functionParameter's variable will not exist if there is no error,
        you can use this to create an error message on error and a sucess
        message on completion.
      </p>
      <br />
      <h2>üìÅ In-Depth Usage Example</h2>
      <p><b>Installation:</b> <code>./</code></p>
      <pre><code>> npm install webcompounder --save-dev</code></pre>
      <br />
      <p>Input File: <code>./src/utils/colors.js</code></p>
      <p>
        <b
          >This file's code does not matter, its just an example of a file that
          will be combined.</b
        >
      </p>
      <pre><code>var colors = {
  red: "#ff0000",
  orange: "#ff5500",
  yellow: "#ffff00",
  green: "#00ff00",
  blue: "#0000ff",
  purple: "#ff00ff",
  white: "#ffffff",
  gray: "#555555",
  black: "#000000"
};</code></pre>
      <br />
      <p>Input File: <code>./src/utils/utils.js</code></p>
      <p>
        <b
          >This file's code does not matter, its just an example of a file that
          will be combined.</b
        >
      </p>
      <pre><code>var utils = {
  colors: colors,
};</code></pre>
      <br />
      <p>Input File: <code>./src/main.js</code></p>
      <p>
        <b
          >This file's code does not matter, its just an example of a file that
          will be combined.</b
        >
      </p>
      <pre><code>var someLibrary = {
  utils: utils,
};</code></pre>
      <br />
      <p><b>Configuration File:</b> <code>./build/config/buildJs.json</code></p>
      <pre><code>{
  "input": ["./src/utils/colors.js", "./src/utils/utils.js", "./src/main.js"],
  "output": "./build/main.build.js",
  "callback": {
    "functionParameter": "error",
    "functionBody": "if (error) { console.error('\n' + error + '\n') } else { console.log('\n' + 'Build Completed' + '\n') }"
  }
}</code></pre>
      <p>
        <b
          >Notice how even though the configuration file is in
          <code>./build/config/</code>, the paths are relative to
          <code>./</code>. This is because <code>./</code> is where
          webCompounder was installed into.</b
        >
      </p>
      <br />
      <p><b>Terminal/Shell:</b> <code>./</code></p>
      <pre><code>> webCompounder --version
1.1.2
> webCompounder ./build/config/buildJs.json
Build Completed</code></pre>
      <p>
        <b
          >You can run <code>webCompounder --version</code> to check the version
          of webCompounder that's installed. This also helps test if
          webCompounder is working.</b
        >
      </p>
      <br />
      <p>Output File: <code>./build/main.build.js</code></p>
      <p>
        <b
          >This file's code does not matter, its just an example of a file that
          was generated.</b
        >
      </p>
      <pre><code>var colors = {
  red: "#ff0000",
  orange: "#ff5500",
  yellow: "#ffff00",
  green: "#00ff00",
  blue: "#0000ff",
  purple: "#ff00ff",
  white: "#ffffff",
  gray: "#555555",
  black: "#000000",
};

var utils = {
  colors: colors,
};

var someLibrary = {
  utils: utils,
};</code></pre>
      <br />
    </main>

    <footer>
      <h1>webCompounder</h1>
      <p>
        Copyright (c) 2022 Ehan Ahamed and contributors <br />
        Licensed Under the UPL-1.0 License <br />
        <a
          href="https://github.com/EhanAhamed/webCompounder/blob/main/LICENSE.txt"
          >See License File</a
        >
      </p>
      <br />
      <br />
      <br />
      <br />
    </footer>
  </body>
</html>
